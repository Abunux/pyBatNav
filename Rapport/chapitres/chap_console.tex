\chapter{Affichage console}
Le module \texttt{bn\_console.py} implémente l'interface en mode console.

L'idée de cette interface est de rendre hommage au style de jeu des années 80 en essayant d'en garder au maximum l'esprit.

\section{Préliminaires}
\subsection{Constantes graphiques}
Pour afficher les grilles nous utilisons des caractères graphiques en unicode (famille Box Drawing de codes U2500 à U257F). Ceux-ci donnent tous les outils afin de fabriquer des grilles, y compris avec des caractères gras. Pour des raisons de commodité, le code de chacun des caractères utilisés est stocké dans une constante (par exemple \texttt{CAR\_CX=u'\textbackslash u253C'} correspond à la croix centrale).

\subsection{Effacer le terminal}
Le module \texttt{os} permet d'une part d'accéder à la version du système d'exploitation avec \texttt{os.name} et, d'autre part, de lancer des commandes système avec \texttt{os.system(commande)}. La combinaison de ces deux commandes permet facilement de pouvoir effacer l'écran en utilisant la commande \texttt{cls} sous Windows et \texttt{clear} sous Linux.

\subsection{Fusion des deux grilles}
Lors d'une partie contre un adversaire, il faut pouvoir afficher côte à côte la grille de suivi du joueur ainsi que sa propre grille avec, au fur et à mesure, les coups joués par l'adversaire. Afin de réaliser cette opération nous utilisons la fonction \texttt{fusion(chaine1, chaine2)}. Celle-ci prend en entrée deux chaînes de caractères et retourne la chaîne fusionnée de la façon suivante : chaque chaîne est convertie en liste en prenant comme séparateur le caractère de retour de ligne \texttt{'\textbackslash n'} grâce à la méthode \texttt{String.join('\textbackslash n')}. Ensuite, en prenant les éléments à tour de rôle les éléments de chacune des listes et en insérant un caractère de trait vertical entre les deux on crée la chaîne fusionnée. 

\subsection{Autres fonctions d'affichage}
La fonction \texttt{centre(chaine, longueur)} centre la chaîne sur un espace de longueur donnée en insérant le nombre d'espaces nécessaires. Cette fonction sera utilisée pour l'affichage des noms des joueurs.

La fonction \texttt{boite(texte, prefixe, longueur)} permet d'encadrer le texte dans une boîte de longueur donnée, chaque ligne étant précédée d'un préfixe. Cette fonction sera utilisée pour afficher la liste des messages pour chaque joueur à chaque tour, les préfixe servant à identifier l'auteur du message.

Notons enfin qu'afin de pouvoir réutiliser le code de ce module dans d'autres contextes (comme une interface en \texttt{tkinter}), la fonction \texttt{print()} a été encapsulée dans une fonction \texttt{info(*args)} de sorte qu'il suffit de surcharger cette dernière pour envoyer l'affichage ailleurs (par exemple dans une boîte de texte dans une fenêtre graphique)

\section{Affichage des grilles}
La classe \texttt{GrilleC(Grille)} hérite de la classe \texttt{Grille} en ajoutant uniquement les fonctions d'affichage.

\subsection{Affichage simple de la grille}
La méthode \texttt{GrilleC.make\_chaine(self)} crée la chaîne de caractères de la grille simple. 

Pour cet affichage, on crée les lignes les unes après les autres en marquant les cases suivant les valeurs de \texttt{Grille.etat}. La seule subtilité provient des premières et de la dernière ligne (à cause des coins).


\subsection{Affichage de la grille avec ses propres bateaux surlignés}
Cette partie est beaucoup plus délicate. L'idée est d'afficher une grille en entourant ses propres bateaux et en marquant les coups joués par l'adversaire (sa grille de suivi). C'est le rôle de la fonction \texttt{GrilleC.make\_chaine\_adverse(self, grille)}, où \texttt{grille} est soit sa propre grille de jeu, soit celle de l'adversaire si on veut tricher (pour les tests bien sûr...) ou en fin de partie, si on a perdu, pour avoir la solution. Par convention, comme \texttt{grille} est une grille de jeu, nous allons noter dans les explications les seuls états possibles par $1$ si la case est occupée par un bateau et $0$ sinon (en fait on ne test que si \texttt{grille.etat[case]==1} ou si \texttt{grille.etat[case]!=1}).

Les contraintes que nous nous fixons sont les suivantes :
\begin{itemize}
\item Les bords des bateaux doivent être en gras
\item Les séparations à l'intérieur d'un bateau doivent être en clair
\item Lorsque deux bateaux se touchent par un coin, il faut bien sûr que ces coins soit en gras (soit une croix en gras)
\end{itemize}

Le bord des cases de la grille se fera sur la ligne du bas (hormis la première ligne) et sur la droite (hormis pour la première colonne). Le cas de la dernière ligne horizontale et de la dernière ligne verticale se fera à part.

Pour savoir la configuration d'une case on va donc devoir tester, outre cette dernière, sa case à droite et sa case en dessous (pour savoir si on commence un bateau, si on le termine, si on est dedans ou encore s'il n'y a pas de bateau dans ce secteur) ainsi que sa case en dessous à droite (pour savoir s'il n'y a pas deux bateaux qui se touchent sur un coin).


\section{Modes de jeu}
\subsection{Jeu solo}

\subsection{Résolution d'un grille par l'ordinateur}

\subsection{Jeu contre l'ordinateur}

