\chapter{Présentation du projet}

\section{Le jeu de la bataille navale}
Le jeu de la bataille navale est un jeu qui se joue à deux joueurs.\\
Chaque joueur dispose d'une grille sur laquelle il place des bateaux rectangulaires de différentes tailles et essaie, à tour de rôle, de deviner l'emplacement des bateaux de l'adversaire par des tirs successifs, ce dernier annonçant à chaque coup \og manqué \fg{} ou \og touché \fg{} (on ne rejoue pas après avoir touché). J'ai pris le parti de ne pas annoncer \og coulé \fg{} lorsque toutes les cases d'un bateau ont été touchées pour rendre les algorithmes un petit peu plus intéressants.\\
Les bateaux peuvent être placés horizontalement ou verticalement et deux bateaux ne peuvent pas se trouver sur des cases adjacentes.

Les paramètres de jeu retenus dans ce projet sont ceux du jeu original, mais ils peuvent être facilement modifiés, à savoir que la grille est un carré 10 cases de côté et la composition de la flotte est la suivante :
\begin{itemize}
\item Un bateau de 5 cases
\item Un bateau de 4 cases
\item Deux bateaux de 3 cases
\item Un bateau de 2 cases
\end{itemize}

\medskip

Notons tout de suite quelques implications stratégiques de ces règles qui seront utilisées dans le projet :
\begin{itemize}
\item Le plus petit bateau étant de taille 2, il suffit de ne tirer que sur une cases sur deux (imaginez les cases noires d'un damier) lors de la recherche d'un bateau.
\item Une fois qu'un bateau a été coulé, on peut éliminer de la recherche toutes ses cases adjacentes.
\item On peut concevoir ce jeu comme un jeu à un seul joueur jouant sur une grille aléatoire.
\end{itemize}

\section{Objectifs du projet}
Mes objectifs ont été les suivants :
\begin{itemize}
\item Définir une structure de données pour modéliser la grille de jeu, ainsi que les joueurs.
\item Implémenter un algorithme de résolution par l'ordinateur qui soit le plus performant possible (en nombre de coups ainsi qu'en temps de résolution d'une grille) et en faire une étude statistique complète.
\item Avoir une interface permettant de jouer contre l'ordinateur, d'une part en mode console et, d'autre part, avec le module \texttt{tkinter}. J'ai également rajouté une interface web en HTML5 utilisant un \texttt{canvas}, une communication via un script \texttt{cgi} et quelques fonctions en Javascript, à titre de démonstration.
\end{itemize}

\section{Liste des modules du projet}
Afin de faciliter les développement et la maintenance du projet, celui-ci a été décomposé en un certain nombre de modules :
\begin{itemize}
\item \texttt{main.py} : le programme principal. Il permet, via un argument en ligne de commande de choisir l'interface de jeu.
\item \texttt{bn\_utiles.py} : contient quelques fonctions utiles ainsi que les constantes du projet.
\item \texttt{bn\_grille.py} : gère la grille et les bateaux.
\item \texttt{bn\_joueur.py} : gère les joueurs et implémente l'algorithme de résolution.
\item \texttt{bn\_stats.py} : fournit les outils d'analyse statistique des résultats de l'algorithme de résolution.
\item \texttt{bn\_console.py} : l'interface en mode console, et l'étude statistique de l'algorithme de résolution.
\item \texttt{bn\_tkinter.py} : l'interface en mode tkinter.
\item \texttt{bn\_webserveur.py} : un serveur web minimum à lancer en premier pour l'interface web.
\end{itemize}

\medskip

Par ailleurs, le dossier \texttt{interface\_web} contient l'interface web dans les fichiers suivants :
\begin{itemize}
\item \texttt{index.html} : la page d'accueil de l'interface web.
\item Le dossier \texttt{cgi-bin} contient le fichier \texttt{bn\_cgi.py} qui gère les pages de jeu, ainsi qu'une copie des fichiers \texttt{bn\_grille.py}, \texttt{bn\_joueur.py} et \texttt{bn\_utiles.py} (un simple lien symbolique suffirait).
\item Le dossier \texttt{css} contient les feuilles de style \texttt{CSS}.
\end{itemize}

\bigskip

L'ensemble du code source du projet a été déposé sur mon compte GitHub à l'adresse \texttt{https://github.com/Abunux/pyBatNav}

\section{À propos de ce rapport et des annexes}
Vu l'ampleur du projet et la contrainte de taille du rapport (j'ai essayé de condenser au maximum mais il y a beaucoup de figures), de nombreux points sont abordés en annexe, à partir de la page \pageref{annexes}. On y trouve notamment les principaux algorithmes du programme, l'étude statistique des différents algorithmes de résolution ainsi que des points techniques du code et un exemple de résolution pas à pas. 

Par ailleurs le code source du projet est très largement commenté pour en faciliter la compréhension.
